{"name":"Unity3D","slug":"Unity3D","count":3,"postlist":[{"title":"Unity3D近期知识点整理(1)","slug":"Unity3D近期知识点整理-1","date":"2020-06-27T03:40:13.000Z","updated":"2020-06-27T04:29:02.965Z","comments":true,"path":"api/articles/Unity3D近期知识点整理-1.json","excerpt":"","keywords":null,"cover":null,"content":"<h3 id=\"1-关于Awake-方法\"><a href=\"#1-关于Awake-方法\" class=\"headerlink\" title=\"1.关于Awake()方法\"></a>1.关于Awake()方法</h3><p>Awake()在组件或脚本中，于程序开始初始化被载入时调用，而Start()在GameObject第一次被渲染时被调用，所以Awake()先于Start()被调用。</p>\n<p>Awake()也不仅仅只是在程序初始化的时候才调用，无论程序运行的任何时刻，只要有组件或者脚本被实例化载入了，他的Awake()就会被调用。(例如动态生成:键盘响应载入脚本等等)</p>\n<h3 id=\"2-父类与子类的关系\"><a href=\"#2-父类与子类的关系\" class=\"headerlink\" title=\"2.父类与子类的关系\"></a>2.父类与子类的关系</h3><p>子类本质上就是一个父类，因为它要实现父类包含的所有的方法。因此父类所有的特点子类都继承了。(比如动物是父类，鸡是子类，鸡也是动物，所以子类就是父类。)</p>\n<h3 id=\"3-关于修饰符在组件里的可见性\"><a href=\"#3-关于修饰符在组件里的可见性\" class=\"headerlink\" title=\"3.关于修饰符在组件里的可见性\"></a>3.关于修饰符在组件里的可见性</h3><p>public修饰的变量可以显示在组件中(Inspector)，但是剩下的private、protected、internal就无法显示了。与此同时还有static修饰符，即使是public的变量加了static也无法显示在组件中。因为static是静态的。不加static，这给变量是属于某个对象的，加了的话这个变量就不属于某个对象，而是属于这个类了。虽然所有的对象都可以访问到，但是在Unity中，挂载到Object上的类实际上就是实例化了一个单独的<strong>对象</strong>，所以无法显示。</p>\n<h3 id=\"4-继承于MonoBehaviour的类，不能直接用-new-来生成对象\"><a href=\"#4-继承于MonoBehaviour的类，不能直接用-new-来生成对象\" class=\"headerlink\" title=\"4.继承于MonoBehaviour的类，不能直接用 new 来生成对象\"></a>4.继承于MonoBehaviour的类，不能直接用 new 来生成对象</h3><p>如果一个类是继承自monobehaviour的，便不能用new来使其实例化，这跟unity3D的编程方式有关，unity3D是组件化编程，除了对象以外一切都是组件(component)，所有继承自monobehaviour的脚本都要绑定到游戏对象(object)上才能运行，需要用GetComponet&lt;&gt;函数来使其实例化(如果目标的类还没有绑定到Object上，可以用AddComponet&lt;&gt;函数直接添加)，而不能用new(new是实例化不了此对象的)，强行用的话运行时会弹出警告，而且new出来的对象会为NULL。只有不是继承自monobehaviour类的才能用new实例化，因此，如果写的脚本是独立于游戏对象之外的话，就不要让其继承自monobehavior。</p>\n<hr>\n<h3 id=\"版权所有，转载请注明地址\"><a href=\"#版权所有，转载请注明地址\" class=\"headerlink\" title=\"版权所有，转载请注明地址\"></a>版权所有，转载请注明地址</h3><p>本文为「&copy;柑茶」原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</p>\n","text":"1.关于Awake()方法Awake()在组件或脚本中，于程序开始初始化被载入时调用，而Start()在GameObject第一次被渲染时被调用，所以Awake()先于Start()被调用。Awake()也不仅仅只是在程序初始化的时候才调用，无论程序运行的任何时刻，只要有组件或者","link":"","raw":null,"photos":[],"categories":[{"name":"Unity3D","slug":"Unity3D","count":3,"path":"api/categories/Unity3D.json"},{"name":"C#","slug":"Unity3D/C","count":1,"path":"api/categories/Unity3D/C.json"}],"tags":[{"name":"Unity3D","slug":"Unity3D","count":4,"path":"api/tags/Unity3D.json"},{"name":"C#","slug":"C","count":2,"path":"api/tags/C.json"}]},{"title":"UGUI学习：（1）Canvas画布的基本认知","slug":"UGUI学习：（1）Canvas画布的基本认知","date":"2020-02-18T11:13:53.000Z","updated":"2020-04-20T11:28:46.093Z","comments":true,"path":"api/articles/UGUI学习：（1）Canvas画布的基本认知.json","excerpt":"<p>Canvas一共有三种渲染模式：</p>","keywords":null,"cover":"/2020/02/18/UGUI%E5%AD%A6%E4%B9%A0%EF%BC%9A%EF%BC%881%EF%BC%89Canvas%E7%94%BB%E5%B8%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E7%9F%A5/1.png","content":null,"text":"Canvas一共有三种渲染模式： [Figure] 在这个模式下UI在场景里就不是单独的存在了，而被视为场景里的一个物体而存在。例如UI可以附加在场景的某个物体上成为其的子物体，使UI跟随物体移动。在制作类似于移动NPC的血条之类的效果时就很方便。版权所有，转载请注明地址本文为「","link":"","raw":null,"photos":[],"categories":[{"name":"Unity3D","slug":"Unity3D","count":3,"path":"api/categories/Unity3D.json"},{"name":"UGUI","slug":"Unity3D/UGUI","count":1,"path":"api/categories/Unity3D/UGUI.json"}],"tags":[{"name":"Unity3D","slug":"Unity3D","count":4,"path":"api/tags/Unity3D.json"},{"name":"UGUI","slug":"UGUI","count":1,"path":"api/tags/UGUI.json"}]},{"title":"Unity和VS中的常用快捷键整理","slug":"Unity和VS中的常用快捷键整理","date":"2020-06-27T02:35:47.000Z","updated":"2020-06-27T03:26:30.829Z","comments":true,"path":"api/articles/Unity和VS中的常用快捷键整理.json","excerpt":"<h3 id=\"一-Visual-Studio常用快捷键\"><a href=\"#一-Visual-Studio常用快捷键\" class=\"headerlink\" title=\"一.Visual Studio常用快捷键\"></a>一.Visual Studio常用快捷键</h3><ul>\n<li><p>快速注释</p>\n<p><strong>Ctrl + K + C</strong></p>\n</li>\n<li><p>取消注释</p>\n<p><strong>Ctrl + K + U</strong></p>\n</li>\n<li><p>格式化代码</p>\n<p><strong>Ctrl + K + D</strong></p>\n</li>\n</ul>","keywords":null,"cover":null,"content":null,"text":"一.Visual Studio常用快捷键快速注释Ctrl + K + C取消注释Ctrl + K + U格式化代码Ctrl + K + D  F5 调试运行  F9 设置断点  F10 逐行执行  F11 一句一句执行 (如果一行中调用了其他方法，那么他会跟踪到那个方法中去。) ","link":"","raw":null,"photos":[],"categories":[{"name":"Unity3D","slug":"Unity3D","count":3,"path":"api/categories/Unity3D.json"}],"tags":[{"name":"Unity3D","slug":"Unity3D","count":4,"path":"api/tags/Unity3D.json"}]}]}