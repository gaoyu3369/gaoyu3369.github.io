{"name":"C#","slug":"C","count":5,"postlist":[{"title":"C#实现Unity3D中的Text组件打字机效果","slug":"C-实现Unity3D中的Text组件打字机效果","date":"2020-06-29T01:25:13.000Z","updated":"2020-06-29T02:28:58.181Z","comments":true,"path":"api/articles/C-实现Unity3D中的Text组件打字机效果.json","excerpt":"<p>实现Text组件一个字一个字显示的打字机效果是非常常见且经常容易遇见的题目，这个效果的实现方法多种多样，记录一下我个人常用的一个相对简单的方法。</p>\n<p>大体的思路，主要是以下几点：</p>\n<ol>\n<li>获取物体的Text组件</li>\n<li>保存Text组件内的文字</li>\n<li>通过保存的文字用Substring方法实时刷新Text组件内的文字来实现打字机效果</li>\n</ol>","keywords":null,"cover":null,"content":null,"text":"实现Text组件一个字一个字显示的打字机效果是非常常见且经常容易遇见的题目，这个效果的实现方法多种多样，记录一下我个人常用的一个相对简单的方法。大体的思路，主要是以下几点：获取物体的Text组件保存Text组件内的文字通过保存的文字用Substring方法实时刷新Text组件内的","link":"","raw":null,"photos":[],"categories":[{"name":"C#","slug":"C","count":5,"path":"api/categories/C.json"}],"tags":[{"name":"Unity3D","slug":"Unity3D","count":6,"path":"api/tags/Unity3D.json"},{"name":"C#","slug":"C","count":4,"path":"api/tags/C.json"}]},{"title":"Unity3D中C#脚本的基础语法","slug":"Unity3D中C-脚本的基础语法","date":"2020-03-20T11:13:53.000Z","updated":"2020-06-27T04:28:35.603Z","comments":true,"path":"api/articles/Unity3D中C-脚本的基础语法.json","excerpt":"<h2 id=\"一-位移与旋转\"><a href=\"#一-位移与旋转\" class=\"headerlink\" title=\"一.位移与旋转\"></a>一.位移与旋转</h2><ol>\n<li><strong>位移</strong></li>\n</ol>\n<p>使用Rotate方法</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">BNUTransR</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.transform.Rotate(<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);    <span class=\"comment\">/*绕x轴每帧旋转2°(x轴,y轴,z轴)</span></span><br><span class=\"line\"><span class=\"comment\">                                           在Rotate方法中数字为旋转度数而非速度*/</span> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"一.位移与旋转位移使用Rotate方法1<br>2<br>3<br>4<br>5<br>6<br>public class BNUTransR : MonoBehaviour &#123;<br>    void Update()&#123;<br>        this.tr","link":"","raw":null,"photos":[],"categories":[{"name":"C#","slug":"C","count":5,"path":"api/categories/C.json"}],"tags":[{"name":"Unity3D","slug":"Unity3D","count":6,"path":"api/tags/Unity3D.json"},{"name":"C#","slug":"C","count":4,"path":"api/tags/C.json"}]},{"title":"省VR技能大赛项目(1)-关于Transform组件的值获取问题","slug":"省VR技能大赛项目-1-关于Transform组件的值获取问题","date":"2020-06-28T04:52:49.000Z","updated":"2020-06-29T02:19:13.215Z","comments":true,"path":"api/articles/省VR技能大赛项目-1-关于Transform组件的值获取问题.json","excerpt":"<p>这几天在做VR省赛的项目时，遇到这么一个需求：</p>","keywords":null,"cover":"/2020/06/28/%E7%9C%81VR%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E9%A1%B9%E7%9B%AE-1-%E5%85%B3%E4%BA%8ETransform%E7%BB%84%E4%BB%B6%E7%9A%84%E5%80%BC%E8%8E%B7%E5%8F%96%E9%97%AE%E9%A2%98/1.png","content":null,"text":"这几天在做VR省赛的项目时，遇到这么一个需求： [Figure] 正是因为看到了这个赋值的问题，我才发现我上面所述的压根儿就没有赋值给transform的问题。不过倒是也又巩固了一下我对于结构体和值传递的记忆。版权所有，转载请注明地址本文为「&copy;柑茶」原创文章，遵循 CC","link":"","raw":null,"photos":[],"categories":[{"name":"C#","slug":"C","count":5,"path":"api/categories/C.json"}],"tags":[{"name":"Unity3D","slug":"Unity3D","count":6,"path":"api/tags/Unity3D.json"},{"name":"C#","slug":"C","count":4,"path":"api/tags/C.json"}]},{"title":"省VR技能大赛项目(2)-关于射线简称和LayerMask问题","slug":"省VR技能大赛项目-2-关于射线简称和LayerMask问题","date":"2020-06-29T03:06:32.000Z","updated":"2020-07-03T02:19:54.044Z","comments":true,"path":"api/articles/省VR技能大赛项目-2-关于射线简称和LayerMask问题.json","excerpt":"","keywords":null,"cover":"/2020/06/29/%E7%9C%81VR%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E9%A1%B9%E7%9B%AE-2-%E5%85%B3%E4%BA%8E%E5%B0%84%E7%BA%BF%E7%AE%80%E7%A7%B0%E5%92%8CLayerMask%E9%97%AE%E9%A2%98/1.png","content":"<p>因为省赛所有的镜头交互基本都需要用到中心点和进度条的方式，所以射线检测是不可或缺的环节。</p>\n<p>射线检测较为基础，但是在不同情况和要求下射线检测的用法也会有所变化，比如同时检测多个物体、只能检测一次等等。所以牢记射线检测的方法以及拓展用法极为重要。</p>\n<h3 id=\"一、射线检测的基本用法\"><a href=\"#一、射线检测的基本用法\" class=\"headerlink\" title=\"一、射线检测的基本用法\"></a>一、射线检测的基本用法</h3><p>射线检测有几个必要的元素：</p>\n<p>1.<strong>Ray</strong>    射线</p>\n<p>Ray(Vector3 origin, Vector3 direction)</p>\n<p>就是以某个位置(origin)朝某个方向(direction)的一条射线，是一个三维坐标。</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ray ray = <span class=\"keyword\">new</span> Ray(transform.position, transform.forward);</span><br></pre></td></tr></table></figure>\n\n<p>生成射线的方法多种多样，目前经常用到的主要是从鼠标点击位置发出、从屏幕中间发出等等。它们的共同点都是需要获取到屏幕信息，然后通过摄像机将射线打入游戏场景，以这两种情况举例：</p>\n<p>屏幕中心：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ray ray = Camera.main.ScreenPointToRay(<span class=\"keyword\">new</span> Vector3(Screen.width / <span class=\"number\">2</span>, Screen.height / <span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"comment\">//通过Screen.width和Screen.height获取屏幕的宽高，然后通过取半值得到屏幕的中心点</span></span><br></pre></td></tr></table></figure>\n\n<p>鼠标位置：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class=\"line\"><span class=\"comment\">//这是实时获取鼠标的位置，如果要设置点击鼠标后才检测，只要给生成射线的语句加上Input.GetMouseButton()的条件即可</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.<strong>RaycastHit</strong>    光线投射碰撞</p>\n<p>用来获取从raycast函数中得到的信息反馈。</p>\n<p>因为RaycastHit用于存储射线碰撞到的第一个对象信息，在使用之前也是需要声明初始化创的，我个人的习惯是命名为hitResult，简写为hitRet。</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RaycastHit hitRet;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>3.<strong>Raycast</strong>    射线检测</p>\n<p>Physics.Raycast(Ray ray, out RaycastHit hitRet, float maxDistance, LayerMask/int layermask);</p>\n<p>ray：射线结构体的信息，包括起点，方向，也就是一条射线。</p>\n<p>hitRet：这条射线所碰撞物体的相关信息。</p>\n<p>maxDistance：这条射线的最大距离。</p>\n<p>layermask：射线遮罩，控制这条射线在特定的层上进行碰撞检测。</p>\n<p><strong><em>Tip:</em></strong>有一点需要非常注意，当你需要使用到layermask的时候，前一个参数maxDistance是<strong>必须要实现的</strong>，要不然layerm将会被当做maxDistance，从而layermask将失去作用。</p>\n<p>4.<strong>LayerMask</strong>    层遮罩</p>\n<p>只选定指定的Layermask层内的碰撞器，其它层内碰撞器忽略检测。</p>\n<p>Unity中的layer层使用Int32的32个位来表示每个层级。</p>\n<p><img src=\"/2020/06/29/%E7%9C%81VR%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E9%A1%B9%E7%9B%AE-2-%E5%85%B3%E4%BA%8E%E5%B0%84%E7%BA%BF%E7%AE%80%E7%A7%B0%E5%92%8CLayerMask%E9%97%AE%E9%A2%98/1.png\" alt=\"1\"></p>\n<p>正是因为layermask用了Int32来表示不同的层级，所以可以直接用int来直接表示特定的层，也可以通过生成LayerMask类对象，再直接指定这个对象。</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//假设自定义第9层为TargetObjects</span></span><br><span class=\"line\">LayerMask layerMask = <span class=\"number\">1</span> &lt;&lt; LayerMask.NameToLayer(<span class=\"string\">\"TargetObjects\"</span>);\t<span class=\"comment\">//TargetObjects层二进制进一位，即只检测该层</span></span><br><span class=\"line\">Physics.Raycast(ray, <span class=\"keyword\">out</span> hitRet, <span class=\"number\">100f</span>, layerMask);</span><br><span class=\"line\"><span class=\"comment\">//等同于：</span></span><br><span class=\"line\">Physics.Raycast(ray, <span class=\"keyword\">out</span> hitRet, <span class=\"number\">100f</span>, <span class=\"number\">9</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果想要实现指定的层<strong>不被检测</strong>，其它层都要被检测，可以直接取反：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LayerMask layerMask = ~(<span class=\"number\">1</span> &lt;&lt; LayerMask.NameToLayer(<span class=\"string\">\"TargetObjects\"</span>));\t<span class=\"comment\">//加上~按位取反</span></span><br><span class=\"line\">Physics.Raycast(ray, <span class=\"keyword\">out</span> hitRet, <span class=\"number\">100f</span>, layerMask);</span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<h3 id=\"版权所有，转载请注明地址\"><a href=\"#版权所有，转载请注明地址\" class=\"headerlink\" title=\"版权所有，转载请注明地址\"></a>版权所有，转载请注明地址</h3><p>本文为「&copy;柑茶」原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</p>\n","text":"因为省赛所有的镜头交互基本都需要用到中心点和进度条的方式，所以射线检测是不可或缺的环节。射线检测较为基础，但是在不同情况和要求下射线检测的用法也会有所变化，比如同时检测多个物体、只能检测一次等等。所以牢记射线检测的方法以及拓展用法极为重要。一、射线检测的基本用法射线检测有几个必要","link":"","raw":null,"photos":[],"categories":[{"name":"C#","slug":"C","count":5,"path":"api/categories/C.json"}],"tags":[{"name":"Unity3D - C#","slug":"Unity3D-C","count":1,"path":"api/tags/Unity3D-C.json"}]},{"title":"Unity3D近期知识点整理(1)","slug":"Unity3D近期知识点整理-1","date":"2020-06-27T03:40:13.000Z","updated":"2020-06-28T04:43:21.257Z","comments":true,"path":"api/articles/Unity3D近期知识点整理-1.json","excerpt":"<h3 id=\"1-关于Awake-方法\"><a href=\"#1-关于Awake-方法\" class=\"headerlink\" title=\"1.关于Awake()方法\"></a>1.关于Awake()方法</h3><p>Awake()在组件或脚本中，于程序开始初始化被载入时调用，而Start()在GameObject第一次被渲染时被调用，所以Awake()先于Start()被调用。</p>\n<p>Awake()也不仅仅只是在程序初始化的时候才调用，无论程序运行的任何时刻，只要有组件或者脚本被实例化载入了，他的Awake()就会被调用。(例如动态生成:键盘响应载入脚本等等)</p>\n<h3 id=\"2-父类与子类的关系\"><a href=\"#2-父类与子类的关系\" class=\"headerlink\" title=\"2.父类与子类的关系\"></a>2.父类与子类的关系</h3><p>子类本质上就是一个父类，因为它要实现父类包含的所有的方法。因此父类所有的特点子类都继承了。(比如动物是父类，鸡是子类，鸡也是动物，所以子类就是父类。)</p>\n<h3 id=\"3-关于修饰符在组件里的可见性\"><a href=\"#3-关于修饰符在组件里的可见性\" class=\"headerlink\" title=\"3.关于修饰符在组件里的可见性\"></a>3.关于修饰符在组件里的可见性</h3><p>public修饰的变量可以显示在组件中(Inspector)，但是剩下的private、protected、internal就无法显示了。</p>","keywords":null,"cover":null,"content":null,"text":"1.关于Awake()方法Awake()在组件或脚本中，于程序开始初始化被载入时调用，而Start()在GameObject第一次被渲染时被调用，所以Awake()先于Start()被调用。Awake()也不仅仅只是在程序初始化的时候才调用，无论程序运行的任何时刻，只要有组件或者","link":"","raw":null,"photos":[],"categories":[{"name":"C#","slug":"C","count":5,"path":"api/categories/C.json"}],"tags":[{"name":"Unity3D","slug":"Unity3D","count":6,"path":"api/tags/Unity3D.json"},{"name":"C#","slug":"C","count":4,"path":"api/tags/C.json"}]}]}