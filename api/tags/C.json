{"name":"C#","slug":"C","count":6,"postlist":[{"title":"C#实现Unity3D中的Text组件打字机效果","slug":"C-实现Unity3D中的Text组件打字机效果","date":"2020-06-29T01:25:13.000Z","updated":"2020-06-29T02:28:58.181Z","comments":true,"path":"api/articles/C-实现Unity3D中的Text组件打字机效果.json","excerpt":"<p>实现Text组件一个字一个字显示的打字机效果是非常常见且经常容易遇见的题目，这个效果的实现方法多种多样，记录一下我个人常用的一个相对简单的方法。</p>\n<p>大体的思路，主要是以下几点：</p>\n<ol>\n<li>获取物体的Text组件</li>\n<li>保存Text组件内的文字</li>\n<li>通过保存的文字用Substring方法实时刷新Text组件内的文字来实现打字机效果</li>\n</ol>","keywords":null,"cover":null,"content":null,"text":"实现Text组件一个字一个字显示的打字机效果是非常常见且经常容易遇见的题目，这个效果的实现方法多种多样，记录一下我个人常用的一个相对简单的方法。大体的思路，主要是以下几点：获取物体的Text组件保存Text组件内的文字通过保存的文字用Substring方法实时刷新Text组件内的","link":"","raw":null,"photos":[],"categories":[{"name":"C#","slug":"C","count":7,"path":"api/categories/C.json"}],"tags":[{"name":"Unity3D","slug":"Unity3D","count":8,"path":"api/tags/Unity3D.json"},{"name":"C#","slug":"C","count":6,"path":"api/tags/C.json"}]},{"title":"Unity3D中C#脚本的基础语法","slug":"Unity3D中C-脚本的基础语法","date":"2020-03-20T11:13:53.000Z","updated":"2020-06-27T04:28:35.603Z","comments":true,"path":"api/articles/Unity3D中C-脚本的基础语法.json","excerpt":"<h2 id=\"一-位移与旋转\"><a href=\"#一-位移与旋转\" class=\"headerlink\" title=\"一.位移与旋转\"></a>一.位移与旋转</h2><ol>\n<li><strong>位移</strong></li>\n</ol>\n<p>使用Rotate方法</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">BNUTransR</span> : <span class=\"title\">MonoBehaviour</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.transform.Rotate(<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);    <span class=\"comment\">/*绕x轴每帧旋转2°(x轴,y轴,z轴)</span></span><br><span class=\"line\"><span class=\"comment\">                                           在Rotate方法中数字为旋转度数而非速度*/</span> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","keywords":null,"cover":null,"content":null,"text":"一.位移与旋转位移使用Rotate方法1<br>2<br>3<br>4<br>5<br>6<br>public class BNUTransR : MonoBehaviour &#123;<br>    void Update()&#123;<br>        this.tr","link":"","raw":null,"photos":[],"categories":[{"name":"C#","slug":"C","count":7,"path":"api/categories/C.json"}],"tags":[{"name":"Unity3D","slug":"Unity3D","count":8,"path":"api/tags/Unity3D.json"},{"name":"C#","slug":"C","count":6,"path":"api/tags/C.json"}]},{"title":"Unity3D近期知识点整理(1)","slug":"Unity3D近期知识点整理-1","date":"2020-06-27T03:40:13.000Z","updated":"2020-06-28T04:43:21.257Z","comments":true,"path":"api/articles/Unity3D近期知识点整理-1.json","excerpt":"<h3 id=\"1-关于Awake-方法\"><a href=\"#1-关于Awake-方法\" class=\"headerlink\" title=\"1.关于Awake()方法\"></a>1.关于Awake()方法</h3><p>Awake()在组件或脚本中，于程序开始初始化被载入时调用，而Start()在GameObject第一次被渲染时被调用，所以Awake()先于Start()被调用。</p>\n<p>Awake()也不仅仅只是在程序初始化的时候才调用，无论程序运行的任何时刻，只要有组件或者脚本被实例化载入了，他的Awake()就会被调用。(例如动态生成:键盘响应载入脚本等等)</p>\n<h3 id=\"2-父类与子类的关系\"><a href=\"#2-父类与子类的关系\" class=\"headerlink\" title=\"2.父类与子类的关系\"></a>2.父类与子类的关系</h3><p>子类本质上就是一个父类，因为它要实现父类包含的所有的方法。因此父类所有的特点子类都继承了。(比如动物是父类，鸡是子类，鸡也是动物，所以子类就是父类。)</p>\n<h3 id=\"3-关于修饰符在组件里的可见性\"><a href=\"#3-关于修饰符在组件里的可见性\" class=\"headerlink\" title=\"3.关于修饰符在组件里的可见性\"></a>3.关于修饰符在组件里的可见性</h3><p>public修饰的变量可以显示在组件中(Inspector)，但是剩下的private、protected、internal就无法显示了。</p>","keywords":null,"cover":null,"content":null,"text":"1.关于Awake()方法Awake()在组件或脚本中，于程序开始初始化被载入时调用，而Start()在GameObject第一次被渲染时被调用，所以Awake()先于Start()被调用。Awake()也不仅仅只是在程序初始化的时候才调用，无论程序运行的任何时刻，只要有组件或者","link":"","raw":null,"photos":[],"categories":[{"name":"C#","slug":"C","count":7,"path":"api/categories/C.json"}],"tags":[{"name":"Unity3D","slug":"Unity3D","count":8,"path":"api/tags/Unity3D.json"},{"name":"C#","slug":"C","count":6,"path":"api/tags/C.json"}]},{"title":"Unity中常用的C#Attribute属性","slug":"Unity中常用的C-Attribute属性","date":"2020-07-28T06:00:02.000Z","updated":"2020-07-28T06:37:57.198Z","comments":true,"path":"api/articles/Unity中常用的C-Attribute属性.json","excerpt":"<h3 id=\"一、什么是Attribute属性：\"><a href=\"#一、什么是Attribute属性：\" class=\"headerlink\" title=\"一、什么是Attribute属性：\"></a>一、什么是Attribute属性：</h3><p>在C#中，attribute是作为一种程序源代码的元素修饰符存在的，因为有的时候我们需要给自己的代码添加一些描述性的说明信息。当这些我们不愿意用注释或内部代码用来描述的信息，被作为attribute代码而编译的话，编译器会将它们生成到metadata中。</p>\n<p>同时，attribute也是一种object。</p>","keywords":null,"cover":"/2020/07/28/Unity%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84C-Attribute%E5%B1%9E%E6%80%A7/1.png","content":null,"text":"一、什么是Attribute属性：在C#中，attribute是作为一种程序源代码的元素修饰符存在的，因为有的时候我们需要给自己的代码添加一些描述性的说明信息。当这些我们不愿意用注释或内部代码用来描述的信息，被作为attribute代码而编译的话，编译器会将它们生成到metada","link":"","raw":null,"photos":[],"categories":[{"name":"C#","slug":"C","count":7,"path":"api/categories/C.json"}],"tags":[{"name":"Unity3D","slug":"Unity3D","count":8,"path":"api/tags/Unity3D.json"},{"name":"C#","slug":"C","count":6,"path":"api/tags/C.json"}]},{"title":"Unity中常用的Mathf函数","slug":"Unity中常用的Mathf函数","date":"2020-12-01T04:17:49.000Z","updated":"2020-12-01T05:11:55.253Z","comments":true,"path":"api/articles/Unity中常用的Mathf函数.json","excerpt":"","keywords":null,"cover":null,"content":"<h3 id=\"一、乒乓函数\"><a href=\"#一、乒乓函数\" class=\"headerlink\" title=\"一、乒乓函数\"></a>一、乒乓函数</h3><h4 id=\"Mathf-PingPong\"><a href=\"#Mathf-PingPong\" class=\"headerlink\" title=\"Mathf.PingPong\"></a>Mathf.PingPong</h4><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mathf.PingPong(<span class=\"keyword\">float</span> t,<span class=\"keyword\">float</span> length);</span><br></pre></td></tr></table></figure>\n\n<p><strong>循环</strong>返回0-length的中间数值。<strong>不会</strong>取到0，也<strong>不会</strong>取到最大值length。t<strong>必须</strong>是一个自变量，不能取<strong><em>固定数值</em></strong>。所以在Unity中一般多用<code>Time.time</code>。</p>\n<h3 id=\"二、线性插值\"><a href=\"#二、线性插值\" class=\"headerlink\" title=\"二、线性插值\"></a>二、线性插值</h3><h4 id=\"Mathf-Lerp\"><a href=\"#Mathf-Lerp\" class=\"headerlink\" title=\"Mathf.Lerp\"></a>Mathf.Lerp</h4><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Mathf.Lerp(<span class=\"keyword\">float</span> start,<span class=\"keyword\">float</span> end,<span class=\"keyword\">float</span> t);</span><br></pre></td></tr></table></figure>\n\n<p>在数值start和end之间，通过<em>t的比例</em>插值获得一个数值。t必须在<strong>0-1之间</strong>。当t=0时，返回值为start；当t=1时，返回值为end。</p>\n<p>与此同时，线性插值适用于很多其他场合，例如向量<code>Vector3.Lerp</code>、颜色<code>Color.Lerp</code>。</p>\n<h3 id=\"三、关于Random-Range的取值范围问题\"><a href=\"#三、关于Random-Range的取值范围问题\" class=\"headerlink\" title=\"三、关于Random.Range的取值范围问题\"></a>三、关于Random.Range的取值范围问题</h3><p><code>Random.Range(a，b);</code>常用来生成随机数，但是在不同情况下边界范围有所不同。</p>\n<ol>\n<li><p>当两数都为<strong>浮点类型</strong>时，返回值即为浮点型，且最大值和最小值<strong>都可以取到</strong>；</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Random.Range(<span class=\"keyword\">float</span> a,<span class=\"keyword\">float</span> b);</span><br><span class=\"line\"><span class=\"comment\">//a≤返回值≤b</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当两数都为<strong>整型</strong>时，返回值即为整型，且<strong>只能取到最小值</strong>；</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Random.Range(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b);</span><br><span class=\"line\"><span class=\"comment\">//a≤返回值&lt;b</span></span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<hr>\n<h3 id=\"版权所有，转载请注明地址\"><a href=\"#版权所有，转载请注明地址\" class=\"headerlink\" title=\"版权所有，转载请注明地址\"></a>版权所有，转载请注明地址</h3><p>本文为「&copy;柑茶」原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</p>\n","text":"一、乒乓函数Mathf.PingPong1<br>Mathf.PingPong(float t,float length);<br>循环返回0-length的中间数值。不会取到0，也不会取到最大值length。t必须是一个自变量，不能取固定数值。所以在Unity中一般多用Time","link":"","raw":null,"photos":[],"categories":[{"name":"C#","slug":"C","count":7,"path":"api/categories/C.json"}],"tags":[{"name":"Unity3D","slug":"Unity3D","count":8,"path":"api/tags/Unity3D.json"},{"name":"C#","slug":"C","count":6,"path":"api/tags/C.json"}]},{"title":"省VR技能大赛项目(1)-关于Transform组件的值获取问题","slug":"省VR技能大赛项目-1-关于Transform组件的值获取问题","date":"2020-06-28T04:52:49.000Z","updated":"2020-06-29T02:19:13.215Z","comments":true,"path":"api/articles/省VR技能大赛项目-1-关于Transform组件的值获取问题.json","excerpt":"<p>这几天在做VR省赛的项目时，遇到这么一个需求：</p>","keywords":null,"cover":"/2020/06/28/%E7%9C%81VR%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E9%A1%B9%E7%9B%AE-1-%E5%85%B3%E4%BA%8ETransform%E7%BB%84%E4%BB%B6%E7%9A%84%E5%80%BC%E8%8E%B7%E5%8F%96%E9%97%AE%E9%A2%98/1.png","content":null,"text":"这几天在做VR省赛的项目时，遇到这么一个需求： [Figure] 正是因为看到了这个赋值的问题，我才发现我上面所述的压根儿就没有赋值给transform的问题。不过倒是也又巩固了一下我对于结构体和值传递的记忆。版权所有，转载请注明地址本文为「&copy;柑茶」原创文章，遵循 CC","link":"","raw":null,"photos":[],"categories":[{"name":"C#","slug":"C","count":7,"path":"api/categories/C.json"}],"tags":[{"name":"Unity3D","slug":"Unity3D","count":8,"path":"api/tags/Unity3D.json"},{"name":"C#","slug":"C","count":6,"path":"api/tags/C.json"}]}]}