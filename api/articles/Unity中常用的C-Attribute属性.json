{"title":"Unity中常用的C#Attribute属性","slug":"Unity中常用的C-Attribute属性","date":"2020-07-28T06:00:02.000Z","updated":"2020-07-28T06:37:57.198Z","comments":true,"path":"api/articles/Unity中常用的C-Attribute属性.json","photos":[],"link":"","excerpt":"一、什么是Attribute属性：在C#中，attribute是作为一种程序源代码的元素修饰符存在的，因为有的时候我们需要给自己的代码添加一些描述性的说明信息。当这些我们不愿意用注释或内部代码用来描述的信息，被作为attribute代码而编译的话，编译器会将它们生成到metadata中。同时，attribute也是一种object。","covers":["/2020/07/28/Unity%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84C-Attribute%E5%B1%9E%E6%80%A7/1.png","/2020/07/28/Unity%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84C-Attribute%E5%B1%9E%E6%80%A7/2.png","/2020/07/28/Unity%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84C-Attribute%E5%B1%9E%E6%80%A7/3.png","/2020/07/28/Unity%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84C-Attribute%E5%B1%9E%E6%80%A7/4.png","/2020/07/28/Unity%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84C-Attribute%E5%B1%9E%E6%80%A7/5.png","/2020/07/28/Unity%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84C-Attribute%E5%B1%9E%E6%80%A7/6.png"],"content":"<h3 id=\"一、什么是Attribute属性：\"><a href=\"#一、什么是Attribute属性：\" class=\"headerlink\" title=\"一、什么是Attribute属性：\"></a>一、什么是Attribute属性：</h3><p>在C#中，attribute是作为一种程序源代码的元素修饰符存在的，因为有的时候我们需要给自己的代码添加一些描述性的说明信息。当这些我们不愿意用注释或内部代码用来描述的信息，被作为attribute代码而编译的话，编译器会将它们生成到metadata中。</p>\n<p>同时，attribute也是一种object。</p>\n<a id=\"more\"></a>\n\n<p>使用attribute有很显著的方便。他是一种会被编译的程序，但却能像注释一样使用。比起使用注释，attribute可以在执行结果中标识函数、返回值等结果，实现一些更加复杂的标识功能。但是，根据一些资料attribute本身并不是修饰符，而是一种类，被实例化的类，通过反编译可以看到这一点。</p>\n<h3 id=\"二、Unity中常用的attribute属性：\"><a href=\"#二、Unity中常用的attribute属性：\" class=\"headerlink\" title=\"二、Unity中常用的attribute属性：\"></a>二、Unity中常用的attribute属性：</h3><h4 id=\"SerializeField\"><a href=\"#SerializeField\" class=\"headerlink\" title=\"[SerializeField]\"></a>[SerializeField]</h4><p>当[SerializeField]附加在<em>private</em>变量前时，该变量仍可以在Insepctor面板上显示。</p>\n<h4 id=\"HideInInspector\"><a href=\"#HideInInspector\" class=\"headerlink\" title=\"[HideInInspector]\"></a>[HideInInspector]</h4><p>当[HideInInspector]附加在<em>public</em>变量前时，该变量将不会在Insepctor面板上显示。</p>\n<p><img src=\"/2020/07/28/Unity%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84C-Attribute%E5%B1%9E%E6%80%A7/1.png\" alt=\"1\"></p>\n<p><img src=\"/2020/07/28/Unity%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84C-Attribute%E5%B1%9E%E6%80%A7/2.png\" alt=\"2\"></p>\n<h4 id=\"Serializable\"><a href=\"#Serializable\" class=\"headerlink\" title=\"[Serializable]\"></a>[Serializable]</h4><p>假如我们想在继承于MonoBehavior的类中引用自己定义的class类，直接用public实例化一个类是无法在Insepctor面板上显示的。</p>\n<p><img src=\"/2020/07/28/Unity%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84C-Attribute%E5%B1%9E%E6%80%A7/3.png\" alt=\"3\"></p>\n<p><img src=\"/2020/07/28/Unity%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84C-Attribute%E5%B1%9E%E6%80%A7/4.png\" alt=\"4\"></p>\n<p>此时，在我们定义的类型上方加上[Serializable]就可以将其在Insepctor上显示。(Tip：[Serializable]的命名空间是using System)</p>\n<p><img src=\"/2020/07/28/Unity%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84C-Attribute%E5%B1%9E%E6%80%A7/5.png\" alt=\"5\"></p>\n<p><img src=\"/2020/07/28/Unity%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84C-Attribute%E5%B1%9E%E6%80%A7/6.png\" alt=\"6\"></p>\n<hr>\n<h3 id=\"版权所有，转载请注明地址\"><a href=\"#版权所有，转载请注明地址\" class=\"headerlink\" title=\"版权所有，转载请注明地址\"></a>版权所有，转载请注明地址</h3><p>本文为「&copy;柑茶」原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</p>\n","categories":[{"name":"C#","slug":"C","count":6,"path":"api/categories/C.json"}],"tags":[{"name":"Unity3D","slug":"Unity3D","count":7,"path":"api/tags/Unity3D.json"},{"name":"C#","slug":"C","count":5,"path":"api/tags/C.json"}]}