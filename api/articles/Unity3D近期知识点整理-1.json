{"title":"Unity3D近期知识点整理(1)","slug":"Unity3D近期知识点整理-1","date":"2020-06-27T03:40:13.000Z","updated":"2020-06-28T04:43:21.257Z","comments":true,"path":"api/articles/Unity3D近期知识点整理-1.json","photos":[],"link":"","excerpt":"1.关于Awake()方法Awake()在组件或脚本中，于程序开始初始化被载入时调用，而Start()在GameObject第一次被渲染时被调用，所以Awake()先于Start()被调用。Awake()也不仅仅只是在程序初始化的时候才调用，无论程序运行的任何时刻，只要有组件或者脚本被实例化载入了，他的Awake()就会被调用。(例如动态生成:键盘响应载入脚本等等)2.父类与子类的关系子类本质上就是一个父类，因为它要实现父类包含的所有的方法。因此父类所有的特点子类都继承了。(比如动物是父类，鸡是子类，鸡也是动物，所以子类就是父类。)3.关于修饰符在组件里的可见性public修饰的变量可以显示在组件中(Inspector)，但是剩下的private、protected、internal就无法显示了。","covers":null,"content":"<h3 id=\"1-关于Awake-方法\"><a href=\"#1-关于Awake-方法\" class=\"headerlink\" title=\"1.关于Awake()方法\"></a>1.关于Awake()方法</h3><p>Awake()在组件或脚本中，于程序开始初始化被载入时调用，而Start()在GameObject第一次被渲染时被调用，所以Awake()先于Start()被调用。</p>\n<p>Awake()也不仅仅只是在程序初始化的时候才调用，无论程序运行的任何时刻，只要有组件或者脚本被实例化载入了，他的Awake()就会被调用。(例如动态生成:键盘响应载入脚本等等)</p>\n<h3 id=\"2-父类与子类的关系\"><a href=\"#2-父类与子类的关系\" class=\"headerlink\" title=\"2.父类与子类的关系\"></a>2.父类与子类的关系</h3><p>子类本质上就是一个父类，因为它要实现父类包含的所有的方法。因此父类所有的特点子类都继承了。(比如动物是父类，鸡是子类，鸡也是动物，所以子类就是父类。)</p>\n<h3 id=\"3-关于修饰符在组件里的可见性\"><a href=\"#3-关于修饰符在组件里的可见性\" class=\"headerlink\" title=\"3.关于修饰符在组件里的可见性\"></a>3.关于修饰符在组件里的可见性</h3><p>public修饰的变量可以显示在组件中(Inspector)，但是剩下的private、protected、internal就无法显示了。<a id=\"more\"></a>与此同时还有static修饰符，即使是public的变量加了static也无法显示在组件中。因为static是静态的。</p>\n<p>不加static，这给变量是属于某个对象的，加了的话这个变量就不属于某个对象，而是属于这个类了。</p>\n<p>虽然所有的对象都可以访问到，但是在Unity中，挂载到Object上的类实际上就是实例化了一个单独的<strong>对象</strong>，所以无法显示。</p>\n<h3 id=\"4-继承于MonoBehaviour的类，不能直接用-new-来生成对象\"><a href=\"#4-继承于MonoBehaviour的类，不能直接用-new-来生成对象\" class=\"headerlink\" title=\"4.继承于MonoBehaviour的类，不能直接用 new 来生成对象\"></a>4.继承于MonoBehaviour的类，不能直接用 new 来生成对象</h3><p>如果一个类是继承自monobehaviour的，便不能用new来使其实例化，这跟unity3D的编程方式有关，unity3D是组件化编程，除了对象以外一切都是组件(component)。</p>\n<p>所有继承自monobehaviour的脚本都要绑定到游戏对象(object)上才能运行，需要用GetComponet&lt;&gt;函数来使其实例化(如果目标的类还没有绑定到Object上，可以用AddComponet&lt;&gt;函数直接添加)，而不能用new(new是实例化不了此对象的)。</p>\n<p>强行用的话运行时会弹出警告，而且new出来的对象会为NULL。只有不是继承自monobehaviour类的才能用new实例化，因此，如果写的脚本是独立于游戏对象之外的话，就不要让其继承自monobehaviour。</p>\n<h3 id=\"5-Update-里会用到的变量要在整个脚本类中声明初始化\"><a href=\"#5-Update-里会用到的变量要在整个脚本类中声明初始化\" class=\"headerlink\" title=\"5.Update()里会用到的变量要在整个脚本类中声明初始化\"></a>5.Update()里会用到的变量要在整个脚本类中声明初始化</h3><h3 id=\"6-浮点数不能用-判断\"><a href=\"#6-浮点数不能用-判断\" class=\"headerlink\" title=\"6.浮点数不能用==判断\"></a>6.浮点数不能用==判断</h3><p>因为浮点数是一个非常接近原数的近似值，并不是完全等于所给予的数值，如果非要用==只能取它与原数的差值的绝对值，然后判断它的大小是否在范围内。(不推荐)</p>\n<h3 id=\"7-关于粒子系统\"><a href=\"#7-关于粒子系统\" class=\"headerlink\" title=\"7.关于粒子系统\"></a>7.关于粒子系统</h3><p>粒子长度要通过<strong>Start lifetime</strong> <strong>粒子生命长度</strong> 和<strong>Start speed</strong> <strong>粒子速度</strong> 两者结合调整。</p>\n<p><strong>Start size</strong> 不仅可以将粒子大小改成固定值，还可以在两个值之间随机。</p>\n<p><strong>Color over lifetime</strong> 用来调整颜色和透明度。</p>\n<p><strong>Size over lifetime</strong> 可以通过粒子生命长度来实现由大变小或者由小变大的效果。</p>\n<p><strong>Render</strong> 里面的 <strong>Render Mode</strong> 可以改成拉伸模式，通过速度拉伸长度等等改变材质的形状。如果条件允许，还可以更改粒子的材质。</p>\n<h3 id=\"8-Find-方法的区别\"><a href=\"#8-Find-方法的区别\" class=\"headerlink\" title=\"8.Find()方法的区别\"></a>8.Find()方法的区别</h3><p><strong>GameObject.Find()</strong> 是从<code>世界全局</code>搜索的。</p>\n<p><strong>transform.Find()</strong> 是从<code>本节点</code>搜索其<code>子节点</code>的(父节点和兄弟节点都不行)。</p>\n<h3 id=\"9-按位取反\"><a href=\"#9-按位取反\" class=\"headerlink\" title=\"9.~  按位取反\"></a>9.~  按位取反</h3><h3 id=\"10-lt-lt-往前进一位-二进制\"><a href=\"#10-lt-lt-往前进一位-二进制\" class=\"headerlink\" title=\"10.&lt;&lt;  往前进一位(二进制)\"></a>10.&lt;&lt;  往前进一位(二进制)</h3><p>这两个在做射线检测的layerMask时经常会用到，用来指定特殊的layer。</p>\n<hr>\n<h3 id=\"版权所有，转载请注明地址\"><a href=\"#版权所有，转载请注明地址\" class=\"headerlink\" title=\"版权所有，转载请注明地址\"></a>版权所有，转载请注明地址</h3><p>本文为「&copy;柑茶」原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</p>\n","categories":[{"name":"C#","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"Unity3D","slug":"Unity3D","count":5,"path":"api/tags/Unity3D.json"},{"name":"C#","slug":"C","count":3,"path":"api/tags/C.json"}]}